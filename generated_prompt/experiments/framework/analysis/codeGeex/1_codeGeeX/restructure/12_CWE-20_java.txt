Input_Code:
@SuppressWarnings({ "unchecked", "rawtypes" })
public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {
    final JSONLexer lexer = parser.lexer;
    switch (lexer.token()) {
        case JSONToken.LITERAL_STRING:
            byte[] bytes = lexer.bytesValue();
            lexer.nextToken(JSONToken.COMMA);
            return (T) bytes;
        case JSONToken.NULL:
            lexer.nextToken(JSONToken.COMMA);
            return null;
        default:
            break;
    }
    JSONArray array = new JSONArray();
    Class componentClass;
    Type componentType;
    if (!(type instanceof GenericArrayType)) {
        componentType =  ((Class) type).getComponentType();
        componentClass = ((Class) type).getComponentType();
    } else {
        componentType = ((GenericArrayType) type).getGenericComponentType();
        if (! (componentType instanceof TypeVariable)) {
            componentClass = TypeUtils.getClass(componentType);
        } else {
            TypeVariable typeVar = (TypeVariable) componentType;
            Type objType = parser.getContext().type;
            if (!(objType instanceof ParameterizedType)) {
                Type type_ = typeVar.getBounds()[0];
                componentClass = TypeUtils.getClass(type_);
            } else {
                ParameterizedType objParamType = (ParameterizedType) objType;
                Type objRawType = objParamType.getRawType();
                Type actualType = null;
                if (objRawType instanceof Class) {
                    TypeVariable[] objTypeParams = ((Class) objRawType).getTypeParameters();
                    int i = 0;
                    while( i < objTypeParams.length) {
                        String i_name = objTypeParams[i].getName();
                        String typeVar_name = typeVar.getName();
                        if (!i_name.equals(typeVar_name)) {
                            i++;
                           continue;
                        }
                        actualType = objParamType.getActualTypeArguments()[i];
                        i++;
                    }
                }
                componentClass = (actualType instanceof Class)? (Class) actualType:Object.class;
            }
        }
    }
   #ToGenerate
    return (T) toObjectArray(parser, componentClass, array);
}
Reference_Code: parser.parseArray(componentType, array, fieldName);

Generated_Code: parser.accept(JSONToken.LBRACKET);  

1. Code Quality Scorer — Task Description

Task Description:
You are to assess the overall quality of the generated code and assign a score from 1 to 5. In addition to evaluating syntactic and structural correctness, you may consult the reference code to guide your assessment of code quality.
Scores of 1–3 indicate the code is poor, with significant issues or errors; scores of 4–5 indicate the code is good, correct, and well-structured.

1: Severe errors; code is not executable or fundamentally broken, especially compared to the reference code.

2: Major issues; multiple errors, hard to follow.

3: Acceptable but with noticeable flaws or weaknesses.

4: Mostly correct, only minor/cosmetic issues.

5: Excellent; fully correct, clean, and well-structured, similar to the reference code.

Please provide both the score and the corresponding binary classification result (poor for scores 1–3, good for scores 4–5).
